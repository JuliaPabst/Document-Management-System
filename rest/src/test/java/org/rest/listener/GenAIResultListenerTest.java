package org.rest.listener;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.rest.dto.DocumentIndexDto;
import org.rest.dto.GenAiResultDto;
import org.rest.model.FileMetadata;
import org.rest.service.FileMetadataService;
import org.springframework.amqp.rabbit.core.RabbitTemplate;

import java.time.Instant;
import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class GenAIResultListenerTest {

    @Mock
    private FileMetadataService fileMetadataService;

    @Mock
    private RabbitTemplate rabbitTemplate;

    @InjectMocks
    private GenAIResultListener listener;

    private GenAiResultDto testResult;
    private FileMetadata testMetadata;

    @BeforeEach
    void setUp() {
        try {
            var field = GenAIResultListener.class.getDeclaredField("searchIndexingQueue");
            field.setAccessible(true);
            field.set(listener, "search-indexing-queue");
        } catch (Exception e) {
            fail("Failed to set searchIndexingQueue: " + e.getMessage());
        }

        testResult = new GenAiResultDto(
                100L,
                "test-object-key",
                "This is the full extracted text from the document. It contains all OCR content.",
                "This is a test summary generated by AI",
                LocalDateTime.now()
        );

        testMetadata = new FileMetadata();
        testMetadata.setId(100L);
        testMetadata.setFilename("test-document.pdf");
        testMetadata.setAuthor("Test Author");
        testMetadata.setFileType("PDF");
        testMetadata.setSize(12345L);
        testMetadata.setObjectKey("test-object-key");
        testMetadata.setUploadTime(Instant.now());
        testMetadata.setSummary("This is a test summary generated by AI");
    }

    @Test
    void handleGenAiResult_Success() {
        // Arrange
        when(fileMetadataService.getFileMetadataById(100L)).thenReturn(testMetadata);

        // Act
        listener.handleGenAiResult(testResult);

        // Assert
        verify(fileMetadataService).updateSummary(100L, testResult.getSummary());
        verify(fileMetadataService).getFileMetadataById(100L);

        ArgumentCaptor<DocumentIndexDto> captor = ArgumentCaptor.forClass(DocumentIndexDto.class);
        verify(rabbitTemplate).convertAndSend(eq("search-indexing-queue"), captor.capture());

        DocumentIndexDto indexDto = captor.getValue();
        assertEquals(100L, indexDto.getDocumentId());
        assertEquals("test-document.pdf", indexDto.getFilename());
        assertEquals("Test Author", indexDto.getAuthor());
        assertEquals("PDF", indexDto.getFileType());
        assertEquals(12345L, indexDto.getSize());
        assertEquals("test-object-key", indexDto.getObjectKey());
        assertEquals(testResult.getExtractedText(), indexDto.getExtractedText());
        assertEquals(testResult.getSummary(), indexDto.getSummary());
        assertNotNull(indexDto.getUploadTime());
        assertNotNull(indexDto.getProcessedTime());
    }

    @Test
    void handleGenAiResult_UpdateSummaryFails_NoIndexingSent() {
        // Arrange
        doThrow(new RuntimeException("DB error")).when(fileMetadataService)
                .updateSummary(100L, testResult.getSummary());

        // Act
        listener.handleGenAiResult(testResult);

        // Assert
        verify(fileMetadataService).updateSummary(100L, testResult.getSummary());
        verify(fileMetadataService, never()).getFileMetadataById(any());
        verify(rabbitTemplate, never()).convertAndSend(eq("search-indexing-queue"), any(DocumentIndexDto.class));
    }

    @Test
    void handleGenAiResult_GetMetadataFails_LogsError() {
        // Arrange
        when(fileMetadataService.getFileMetadataById(100L))
                .thenThrow(new RuntimeException("Metadata not found"));

        // Act
        listener.handleGenAiResult(testResult);

        // Assert
        verify(fileMetadataService).updateSummary(100L, testResult.getSummary());
        verify(fileMetadataService).getFileMetadataById(100L);
        verify(rabbitTemplate, never()).convertAndSend(eq("search-indexing-queue"), any(DocumentIndexDto.class));
    }

    @Test
    void handleGenAiResult_RabbitMQFails_LogsError() {
        // Arrange
        when(fileMetadataService.getFileMetadataById(100L)).thenReturn(testMetadata);
        doThrow(new RuntimeException("RabbitMQ error"))
                .when(rabbitTemplate).convertAndSend(eq("search-indexing-queue"), any(DocumentIndexDto.class));

        // Act & Assert (should not throw exception)
        assertDoesNotThrow(() -> listener.handleGenAiResult(testResult));

        verify(fileMetadataService).updateSummary(100L, testResult.getSummary());
        verify(fileMetadataService).getFileMetadataById(100L);
        verify(rabbitTemplate).convertAndSend(eq("search-indexing-queue"), any(DocumentIndexDto.class));
    }

    @Test
    void handleGenAiResult_ExtractedTextIsIncluded() {
        // Arrange
        String longExtractedText = "A".repeat(5000);
        GenAiResultDto resultWithLongText = new GenAiResultDto(
                100L,
                "test-object-key",
                longExtractedText,
                "Short summary",
                LocalDateTime.now()
        );
        
        when(fileMetadataService.getFileMetadataById(100L)).thenReturn(testMetadata);

        // Act
        listener.handleGenAiResult(resultWithLongText);

        // Assert
        ArgumentCaptor<DocumentIndexDto> captor = ArgumentCaptor.forClass(DocumentIndexDto.class);
        verify(rabbitTemplate).convertAndSend(eq("search-indexing-queue"), captor.capture());

        DocumentIndexDto indexDto = captor.getValue();
        assertEquals(longExtractedText, indexDto.getExtractedText(),
                "Full extracted text should be included in index DTO");
    }
}
