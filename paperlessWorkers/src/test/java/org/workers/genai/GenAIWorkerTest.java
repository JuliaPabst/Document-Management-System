package org.workers.genai;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.workers.dto.GenAiResultDto;
import org.workers.dto.OcrResultDto;
import org.workers.service.OpenAIService;

import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class GenAIWorkerTest {

    @Mock
    private RabbitTemplate rabbitTemplate;

    @Mock
    private OpenAIService openAIService;

    @InjectMocks
    private GenAIWorker genAIWorker;

    private OcrResultDto testOcrResult;
    private String testSummary;

    @BeforeEach
    void setUp() {
        try {
            var field = GenAIWorker.class.getDeclaredField("resultQueueName");
            field.setAccessible(true);
            field.set(genAIWorker, "genai-result-queue");
        } catch (Exception e) {
            fail("Failed to set resultQueueName: " + e.getMessage());
        }

        testOcrResult = new OcrResultDto(
                123L,
                "test-object-key",
                "test-bucket",
                "This is the extracted text from OCR processing. It contains very important information.",
                LocalDateTime.now(),
                "Tesseract 5.0"
        );

        testSummary = "Test summary generated by AI";
    }

    @Test
    void processGenAiTask_Success() {
        // Arrange
        when(openAIService.generateSummary(testOcrResult.getExtractedText()))
                .thenReturn(testSummary);

        // Act
        genAIWorker.processGenAiTask(testOcrResult);

        // Assert
        verify(openAIService).generateSummary(testOcrResult.getExtractedText());
        
        ArgumentCaptor<GenAiResultDto> captor = ArgumentCaptor.forClass(GenAiResultDto.class);
        verify(rabbitTemplate).convertAndSend(eq("genai-result-queue"), captor.capture());

        GenAiResultDto capturedResult = captor.getValue();
        assertEquals(testOcrResult.getDocumentId(), capturedResult.getDocumentId());
        assertEquals(testOcrResult.getObjectKey(), capturedResult.getObjectKey());
        assertEquals(testOcrResult.getExtractedText(), capturedResult.getExtractedText());
        assertEquals(testSummary, capturedResult.getSummary());
        assertNotNull(capturedResult.getProcessedAt());
    }

    @Test
    void processGenAiTask_OpenAIServiceThrowsException() {
        // Arrange
        when(openAIService.generateSummary(testOcrResult.getExtractedText()))
                .thenThrow(new RuntimeException("OpenAI API error"));

        // Act & Assert (should not throw exception, just log error)
        assertDoesNotThrow(() -> genAIWorker.processGenAiTask(testOcrResult));
        
        verify(openAIService).generateSummary(testOcrResult.getExtractedText());
        verify(rabbitTemplate, never()).convertAndSend(eq("genai-result-queue"), any(GenAiResultDto.class));
    }

    @Test
    void processGenAiTask_RabbitTemplateThrowsException() {
        // Arrange
        when(openAIService.generateSummary(testOcrResult.getExtractedText()))
                .thenReturn(testSummary);
        doThrow(new RuntimeException("RabbitMQ connection error"))
                .when(rabbitTemplate).convertAndSend(eq("genai-result-queue"), any(GenAiResultDto.class));

        // Act & Assert (should not throw exception, just log error)
        assertDoesNotThrow(() -> genAIWorker.processGenAiTask(testOcrResult));
        
        verify(openAIService).generateSummary(testOcrResult.getExtractedText());
        verify(rabbitTemplate).convertAndSend(eq("genai-result-queue"), any(GenAiResultDto.class));
    }

    @Test
    void processGenAiTask_ExtractedTextPassedThrough() {
        // Arrange
        String longExtractedText = "A".repeat(1000); // Long text
        OcrResultDto ocrWithLongText = new OcrResultDto(
                456L,
                "another-key",
                "bucket",
                longExtractedText,
                LocalDateTime.now(),
                "Tesseract 5.0"
        );
        
        when(openAIService.generateSummary(longExtractedText))
                .thenReturn("Short summary");

        // Act
        genAIWorker.processGenAiTask(ocrWithLongText);

        // Assert
        ArgumentCaptor<GenAiResultDto> captor = ArgumentCaptor.forClass(GenAiResultDto.class);
        verify(rabbitTemplate).convertAndSend(eq("genai-result-queue"), captor.capture());

        GenAiResultDto result = captor.getValue();
        assertEquals(longExtractedText, result.getExtractedText(), 
                "Extracted text should be passed through unchanged");
        assertEquals("Short summary", result.getSummary());
    }
}
